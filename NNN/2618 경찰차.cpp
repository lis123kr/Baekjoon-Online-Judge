//#include<stdio.h>
//#include<string.h>
//int n, w, a[1001], b[1001], dp[1001][1001], pre[1001];
//int min(int a, int b) { return a > b ? b : a; }
//int inline abs(int a) { return (a) >= 0 ? (a) : ((-1)*(a)); }
//int solve(int p, int q) {
//	if (p == w || q == w)
//		return 0;
//	if (dp[p][q] != -1)
//		return dp[p][q];
//	int m = p > q ? p : q;
//	if (p == 0) {
//		a[0] = b[0] = 1;
//	}
//	else if (q == 0) {
//		a[0] = b[0] = n;
//	}
//	int tmp = solve(m + 1, q) + abs(a[m + 1] - a[p]) + abs(b[m + 1] - b[p]);
//	int tmp1 = solve(p, m + 1) + abs(a[m + 1] - a[q]) + abs(b[m + 1] - b[q]);
//	pre[m + 1] = tmp > tmp1 ? 2 : 1;
//	return dp[p][q] = min(tmp, tmp1);
//}
//int main() {
//	memset(dp, -1, sizeof(dp));
//	scanf("%d %d", &n, &w);
//	for (int i = 1; i <= w; i++)
//		scanf("%d %d", &a[i], &b[i]);
//	int m1 = solve(1, 0) + abs(a[1] - 1) + abs(b[1] - 1);
//	int m2 = solve(0, 1) + abs(a[1] - n) + abs(b[1] - n);
//	printf("%d\n", min(m1, m2));
//	pre[1] = m1 > m2 ? 2 : 1;
//	for (int i = 1; i <= w; i++)
//		printf("%d\n", pre[i]);
//	return 0;
//}

//풀이
//이 문제는 처리해야 하는 사건들에 대한 정보가 주어졌을 때, 두 대의 경찰차를 이
//용하여 최소 거리를 이동하며 사건을 맡는 방법을 찾아내는 문제이다.각 경찰이 사
//건을 처리하면 해당 경찰은 해당 위치에 있게 되므로, 가능한 경우가 얼마 되지 않음
//을 알 수 있다.따라서 이러한 경우들을 잘 추적하면서, 각 경우의 최소 이동 거리를
//구해 나가는 동적 계획법으로 해결할 수 있다.즉, 두 경찰차의 현재 위치와 다음 처
//리할 사건을 변수로 두어, 현재 사건에 두 경찰차 중 어느 것을 배치하는 것이 유리
//한가를 계산하여 최적화하는 방향으로 경찰차를 선택해 나가면 된다.D[i][j]를 현재 i번째 사건까지 처리했고, 나머지 하나의 경찰차가 j번 사건 현장에 출
//동하여 있을 때 거리의 최소값으로 정의한다.이 때 편의를 위해서 i > j가 항상 만족
//된다고 생각하자.이제 가능한 경우는 i - 1번 사건 현장에 있던 경찰차가 i번으로 이동
//한 경우와, 다른 k번 사건 현장에 있던 경찰차가 i번으로 이동한 경우가 있음을 알
//수 있다.따라서 D[i - 1][j] + (i번과 i + 1번 사이의 거리)와 D[j][k] + (i번과 k번 사이의
//	거리) 중 최소값을 선택해 나가면 된다.이 때 각각의 수식은 각각의 경우에 차례로
//	대응된다.이와 같은 방식으로 D 배열을 구한 후에, 사건이 N개일 때, D[N][i]들 중
//	최소값이 구하고자 하는 답이 된다.